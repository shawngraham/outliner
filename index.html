<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Note Cards Outliner</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600&family=Inter:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f5e6d3 0%, #e8d5c4 100%);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #header {
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            padding: 16px 24px;
            border-bottom: 1px solid rgba(139, 90, 60, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        h1 {
            font-family: 'Crimson Pro', serif;
            font-size: 24px;
            font-weight: 600;
            color: #5a3825;
            letter-spacing: -0.5px;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-size: 13px;
            color: #5a3825;
            max-width: 280px;
            border: 1px solid rgba(139, 90, 60, 0.15);
        }

        #instructions p {
            margin-bottom: 6px;
            line-height: 1.4;
        }

        #instructions p:last-child {
            margin-bottom: 0;
        }

        #instructions strong {
            font-weight: 500;
            color: #3a2415;
        }

        #reset-button {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 90, 60, 0.3);
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: #5a3825;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        #reset-button:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #b8885d;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        #load-button {
            position: absolute;
            top: 20px;
            right: 140px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 90, 60, 0.3);
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: #5a3825;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        #load-button:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #b8885d;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        #export-button {
            position: absolute;
            top: 20px;
            right: 280px;
            padding: 8px 16px;
            background: rgba(184, 136, 93, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 90, 60, 0.5);
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        #export-button:hover {
            background: rgba(166, 122, 82, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        #edit-overlay {
            position: absolute;
            background: white;
            border: 2px solid #b8885d;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1000;
            min-width: 300px;
        }

        #edit-overlay.active {
            display: block;
        }

        #edit-overlay label {
            display: block;
            font-family: 'Crimson Pro', serif;
            font-weight: 600;
            color: #3a2415;
            margin-bottom: 6px;
            font-size: 14px;
        }

        #edit-overlay input,
        #edit-overlay textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d4a574;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            margin-bottom: 12px;
            color: #3a2415;
        }

        #edit-overlay input:focus,
        #edit-overlay textarea:focus {
            outline: none;
            border-color: #b8885d;
            box-shadow: 0 0 0 3px rgba(184, 136, 93, 0.1);
        }

        #edit-overlay textarea {
            resize: vertical;
            min-height: 80px;
            font-family: 'Inter', sans-serif;
        }

        #edit-overlay .buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        #edit-overlay button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        #edit-overlay button.save {
            background: #b8885d;
            color: white;
        }

        #edit-overlay button.save:hover {
            background: #a67a52;
        }

        #edit-overlay button.cancel {
            background: #e8d5c4;
            color: #5a3825;
        }

        #edit-overlay button.cancel:hover {
            background: #d4c2b1;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>Note Cards Outliner</h1>
        <p><small>Begin with the demo notes at left, upload your own md files, or double click to create your own notes to organize.</small></p>
    </div>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
        <input type="file" id="file-input" accept=".md,.markdown" multiple style="display: none;">
        <button id="export-button" title="Export cards as a markdown file">Export to Markdown</button>
        <button id="load-button" title="Load markdown files from your computer">Load Files</button>
        <button id="reset-button" title="Clear all data and reset">Reset Canvas</button>
        <div id="instructions">
            <p><strong>Load Files button</strong> to import .md files</p>
            <p><strong>Drag empty space</strong> to pan the canvas</p>
            <p><strong>Double-click canvas</strong> to create a note</p>
            <p><strong>Double-click card</strong> to edit it</p>
            <p><strong>Double-click connection</strong> to delete it</p>
            <p><strong>Drag cards</strong> to reposition them</p>
            <p><strong>Click header</strong> to expand/collapse</p>
            <p><strong>Drag onto another card</strong> to connect</p>
            <p><strong>Export button</strong> creates ordered outline</p>
        </div>
        <div id="edit-overlay">
            <label>Title:</label>
            <input type="text" id="edit-title" placeholder="Enter note title">
            <label>Content:</label>
            <textarea id="edit-content" placeholder="Enter note content"></textarea>
            <div class="buttons">
                <button class="cancel" id="edit-cancel">Cancel</button>
                <button class="save" id="edit-save">Save</button>
            </div>
        </div>
    </div>

    <script>
        /*
         * NOTE CARDS OUTLINER
         * 
         * NO CONFIGURATION NEEDED!
         * 
         * How to use:
         * 1. Click "Load Files" button to select your markdown files (.md)
         * 2. Each file becomes one or more cards on the canvas
         * 3. Arrange, connect, and edit cards as needed
         * 4. Click "Export to Markdown" to save your organized outline
         * 
         * Your loaded files and work are saved in the browser and persist
         * between sessions. You can load new files anytime.
         * 
         * SUPPORTED FILE FORMATS:
         * 
         * Format 1 - One file = One card:
         * # Card Title (optional - first heading becomes title)
         * Card content goes here...
         * Multiple paragraphs supported.
         * 
         * Format 2 - One file = Multiple cards (using separators):
         * # First Card Title
         * Content for first card...
         * #-------
         * # Second Card Title
         * Content for second card...
         * #-------
         * # Third Card Title
         * Content for third card...
         * 
         * The app automatically detects which format you're using!
         * 
         * Buttons:
         * - "Load Files": Select .md files from your computer
         * - "Export to Markdown": Download ordered outline following connections
         * - "Reset Canvas": Clear everything and start fresh
         * 
         * Export Logic:
         * Starts with the topmost card (highest on canvas), follows connection
         * arrows to determine order. ONLY connected cards are exported - unconnected
         * cards are excluded. This lets you work on multiple outlines and export
         * only the connected path you want. Titles are formatted as [Title] in 
         * markdown link format.
         * 
         * If no files are loaded, the app shows example placeholder cards.
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Connection lines - declare early
        const connections = [];

        // Canvas panning
        let panOffsetX = 0;
        let panOffsetY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;

        // LocalStorage persistence
        const STORAGE_KEY = 'noteCardsOutliner';
        const STORAGE_KEY_FILES = 'noteCardsOutliner_files';
        
        // Store loaded file data
        let loadedFiles = [];

        function saveFilesToLocalStorage() {
            localStorage.setItem(STORAGE_KEY_FILES, JSON.stringify(loadedFiles));
        }

        function loadFilesFromLocalStorage() {
            const stored = localStorage.getItem(STORAGE_KEY_FILES);
            if (stored) {
                try {
                    loadedFiles = JSON.parse(stored);
                    return true;
                } catch (e) {
                    console.error('Failed to load files from localStorage:', e);
                    return false;
                }
            }
            return false;
        }

        async function loadMarkdownFromFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`Failed to load ${filename}`);
                }
                const text = await response.text();
                
                // Parse the markdown file as a single card
                const lines = text.trim().split('\n');
                let title = filename.replace('.md', ''); // Default to filename
                let content = text;
                
                // If first line is a heading, use it as title
                if (lines[0].startsWith('#')) {
                    title = lines[0].replace(/^#+\s*/, '').trim();
                    content = lines.slice(1).join('\n').trim();
                }
                
                return { title, content };
            } catch (error) {
                console.warn('Could not load markdown file:', error);
                return null;
            }
        }

        function saveToLocalStorage() {
            const data = {
                cards: cards.map(card => ({
                    x: card.x,
                    y: card.y,
                    title: card.title,
                    content: card.content,
                    expanded: card.expanded,
                    index: card.index
                })),
                connections: connections.map(conn => ({
                    fromIndex: cards.indexOf(conn.from),
                    toIndex: cards.indexOf(conn.to)
                })),
                panOffset: {
                    x: panOffsetX,
                    y: panOffsetY
                }
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        function loadFromLocalStorage() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (!stored) return false;

            try {
                const data = JSON.parse(stored);
                
                // Clear existing cards and connections
                cards.length = 0;
                connections.length = 0;

                // Restore cards
                data.cards.forEach(cardData => {
                    const card = new Card(
                        cardData.x,
                        cardData.y,
                        { title: cardData.title, content: cardData.content },
                        cardData.index
                    );
                    card.expanded = cardData.expanded;
                    if (card.expanded) {
                        card.height = card.calculateExpandedHeight();
                    }
                    cards.push(card);
                });

                // Restore connections
                data.connections.forEach(connData => {
                    if (connData.fromIndex >= 0 && connData.toIndex >= 0 &&
                        connData.fromIndex < cards.length && connData.toIndex < cards.length) {
                        connections.push({
                            from: cards[connData.fromIndex],
                            to: cards[connData.toIndex]
                        });
                    }
                });

                // Restore pan offset
                if (data.panOffset) {
                    panOffsetX = data.panOffset.x;
                    panOffsetY = data.panOffset.y;
                }

                return true;
            } catch (e) {
                console.error('Failed to load from localStorage:', e);
                return false;
            }
        }

        // Set canvas size
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if (cards.length > 0) {
                draw();
            }
        }

        // Placeholder markdown data
        const markdownData = `# Introduction to Outlining
This is the foundational concept for organizing thoughts and creating structured documents.
#-------
# Main Ideas
- Hierarchical organization
- Visual connections
- Flexible restructuring
#-------
# Supporting Details
Add specific examples, quotes, and evidence to support your main ideas.
#-------
# Key Arguments
Present your strongest points here with clear reasoning and logic.
#-------
# Counter Arguments
Consider opposing views and how to address them effectively.
#-------
# Conclusion
Synthesize your ideas and provide clear takeaways for the reader.`;

        // Parse markdown into cards
        function parseMarkdown(text) {
            const sections = text.split('#-------').map(s => s.trim());
            return sections.map(section => {
                const lines = section.split('\n');
                const title = lines[0].replace(/^#+\s*/, '').trim();
                const content = lines.slice(1).join('\n').trim();
                return { title, content };
            });
        }

        // Card class
        class Card {
            constructor(x, y, data, index) {
                this.x = x;
                this.y = y;
                this.width = 280;
                this.collapsedHeight = 60;
                this.height = this.collapsedHeight;
                this.title = data.title || 'New Note';
                this.content = data.content || '';
                this.expanded = false;
                this.index = index;
                this.connections = [];
                this.isDragging = false;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;
                this.isEditing = false;
                
                // Color palette - warm, muted tones
                const colors = [
                    { bg: '#fff9f0', border: '#d4a574', accent: '#b8885d' },
                    { bg: '#fef5e7', border: '#c9a67a', accent: '#a68a5f' },
                    { bg: '#f9f3ea', border: '#d0a87e', accent: '#b39268' },
                    { bg: '#fdf8f0', border: '#c8a178', accent: '#ab8c62' },
                    { bg: '#fefaf2', border: '#cca67b', accent: '#af9065' },
                    { bg: '#f8f2e8', border: '#d2a980', accent: '#b59469' }
                ];
                this.color = colors[index % colors.length];
            }

            draw() {
                // Shadow
                ctx.save();
                ctx.shadowColor = 'rgba(90, 56, 37, 0.15)';
                ctx.shadowBlur = 12;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;

                // Card background
                ctx.fillStyle = this.color.bg;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                ctx.restore();

                // Border
                ctx.strokeStyle = this.color.border;
                ctx.lineWidth = 1.5;
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                // Top accent bar
                ctx.fillStyle = this.color.accent;
                ctx.fillRect(this.x, this.y, this.width, 4);

                // Title area
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillRect(this.x, this.y + 4, this.width, this.collapsedHeight - 4);

                // Title text
                ctx.fillStyle = '#3a2415';
                ctx.font = '600 16px "Crimson Pro", serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                
                const titleText = this.truncateText(this.title, this.width - 50);
                ctx.fillText(titleText, this.x + 16, this.y + 32);

                // Expand/collapse indicator
                ctx.font = '14px Inter';
                ctx.fillStyle = this.color.accent;
                ctx.textAlign = 'right';
                ctx.fillText(this.expanded ? 'âˆ’' : '+', this.x + this.width - 16, this.y + 32);

                // Content (if expanded)
                if (this.expanded) {
                    ctx.fillStyle = '#5a3825';
                    ctx.font = '13px Inter';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';

                    const lines = this.wrapText(this.content, this.width - 32);
                    const lineHeight = 18;
                    
                    // Draw all lines
                    for (let i = 0; i < lines.length; i++) {
                        ctx.fillText(lines[i], this.x + 16, this.y + this.collapsedHeight + 12 + (i * lineHeight));
                    }
                }
            }

            truncateText(text, maxWidth) {
                const metrics = ctx.measureText(text);
                if (metrics.width <= maxWidth) return text;
                
                let truncated = text;
                while (ctx.measureText(truncated + '...').width > maxWidth && truncated.length > 0) {
                    truncated = truncated.slice(0, -1);
                }
                return truncated + '...';
            }

            wrapText(text, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';

                for (const word of words) {
                    const testLine = currentLine + (currentLine ? ' ' : '') + word;
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth && currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                }
                
                if (currentLine) {
                    lines.push(currentLine);
                }
                
                return lines;
            }

            containsPoint(x, y) {
                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }

            containsHeaderPoint(x, y) {
                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.collapsedHeight;
            }

            calculateExpandedHeight() {
                if (!this.content) {
                    return this.collapsedHeight + 40; // Minimum expanded height
                }
                
                // Calculate how many lines the content needs
                const lines = this.wrapText(this.content, this.width - 32);
                const lineHeight = 18;
                const topPadding = 12;
                const bottomPadding = 16;
                
                // Calculate total height needed
                const contentHeight = lines.length * lineHeight;
                return this.collapsedHeight + topPadding + contentHeight + bottomPadding;
            }

            toggleExpanded() {
                this.expanded = !this.expanded;
                this.height = this.expanded ? this.calculateExpandedHeight() : this.collapsedHeight;
            }

            getCenter() {
                return {
                    x: this.x + this.width / 2,
                    y: this.y + this.height / 2
                };
            }
        }

        // Initialize cards
        const cards = [];
        const stackX = 40;
        const stackY = 80;
        const stackOffset = 12;

        async function initializeCards() {
            // Try to load from localStorage first
            const loaded = loadFromLocalStorage();

            if (!loaded) {
                // Try to load files that were previously loaded by user
                const hasStoredFiles = loadFilesFromLocalStorage();
                
                if (hasStoredFiles && loadedFiles.length > 0) {
                    // Create cards from stored file data
                    loadedFiles.forEach((fileData, index) => {
                        const card = new Card(
                            stackX,
                            stackY + (index * stackOffset),
                            { title: fileData.title, content: fileData.content },
                            index
                        );
                        cards.push(card);
                    });
                } else {
                    // No files loaded yet - create default cards from hardcoded markdown
                    const cardData = parseMarkdown(markdownData);
                    cardData.forEach((data, index) => {
                        const card = new Card(
                            stackX,
                            stackY + (index * stackOffset),
                            data,
                            index
                        );
                        cards.push(card);
                    });
                }
            }

            // Draw the canvas
            draw();
        }

        // Drawing function
        function drawConnection(from, to) {
            const fromCenter = from.getCenter();
            const toCenter = to.getCenter();

            ctx.save();
            
            // Draw curved line
            ctx.strokeStyle = '#b8885d';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            ctx.beginPath();
            ctx.moveTo(fromCenter.x, fromCenter.y);
            
            // Control points for bezier curve
            const dx = toCenter.x - fromCenter.x;
            const dy = toCenter.y - fromCenter.y;
            const cp1x = fromCenter.x + dx * 0.5;
            const cp1y = fromCenter.y;
            const cp2x = toCenter.x - dx * 0.5;
            const cp2y = toCenter.y;
            
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, toCenter.x, toCenter.y);
            ctx.stroke();

            // Arrow head
            ctx.setLineDash([]);
            const angle = Math.atan2(dy, dx);
            const arrowLength = 10;
            
            ctx.beginPath();
            ctx.moveTo(toCenter.x, toCenter.y);
            ctx.lineTo(
                toCenter.x - arrowLength * Math.cos(angle - Math.PI / 6),
                toCenter.y - arrowLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.moveTo(toCenter.x, toCenter.y);
            ctx.lineTo(
                toCenter.x - arrowLength * Math.cos(angle + Math.PI / 6),
                toCenter.y - arrowLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.stroke();
            
            ctx.restore();
        }

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply panning transformation
            ctx.save();
            ctx.translate(panOffsetX, panOffsetY);

            // Draw connections first (behind cards)
            connections.forEach(conn => {
                drawConnection(conn.from, conn.to);
            });

            // Draw cards
            cards.forEach(card => card.draw());

            // Draw temporary connection line if dragging
            if (draggedCard && isDraggingForConnection) {
                const fromCenter = draggedCard.getCenter();
                ctx.save();
                ctx.strokeStyle = 'rgba(184, 136, 93, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(fromCenter.x, fromCenter.y);
                ctx.lineTo(mouseX - panOffsetX, mouseY - panOffsetY);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore(); // Restore transformation
        }

        // Mouse interaction
        let draggedCard = null;
        let isDraggingForConnection = false;
        let mouseX = 0;
        let mouseY = 0;
        let clickStartTime = 0;
        let clickStartX = 0;
        let clickStartY = 0;

        // Helper function to convert screen coordinates to canvas coordinates
        function screenToCanvas(screenX, screenY) {
            return {
                x: screenX - panOffsetX,
                y: screenY - panOffsetY
            };
        }

        // Helper function to calculate distance from point to line segment
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) {
                param = dot / lenSq;
            }

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Function to find connection at point
        function findConnectionAtPoint(canvasX, canvasY) {
            const threshold = 10; // pixels
            
            for (let i = 0; i < connections.length; i++) {
                const conn = connections[i];
                const from = conn.from.getCenter();
                const to = conn.to.getCenter();
                
                const distance = distanceToLineSegment(canvasX, canvasY, from.x, from.y, to.x, to.y);
                
                if (distance < threshold) {
                    return i;
                }
            }
            return -1;
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const canvasCoords = screenToCanvas(screenX, screenY);
            
            clickStartTime = Date.now();
            clickStartX = screenX;
            clickStartY = screenY;

            // Check cards from top to bottom (reverse order)
            let foundCard = false;
            for (let i = cards.length - 1; i >= 0; i--) {
                if (cards[i].containsPoint(canvasCoords.x, canvasCoords.y)) {
                    draggedCard = cards[i];
                    draggedCard.dragOffsetX = canvasCoords.x - draggedCard.x;
                    draggedCard.dragOffsetY = canvasCoords.y - draggedCard.y;
                    
                    // Move to top of stack
                    cards.splice(i, 1);
                    cards.push(draggedCard);
                    foundCard = true;
                    break;
                }
            }

            // If no card found, start panning
            if (!foundCard) {
                isPanning = true;
                panStartX = screenX - panOffsetX;
                panStartY = screenY - panOffsetY;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            if (isPanning) {
                // Pan the canvas
                panOffsetX = mouseX - panStartX;
                panOffsetY = mouseY - panStartY;
                draw();
            } else if (draggedCard) {
                const canvasCoords = screenToCanvas(mouseX, mouseY);
                const dx = Math.abs(mouseX - clickStartX);
                const dy = Math.abs(mouseY - clickStartY);
                
                if (dx > 5 || dy > 5) {
                    isDraggingForConnection = true;
                    draggedCard.x = canvasCoords.x - draggedCard.dragOffsetX;
                    draggedCard.y = canvasCoords.y - draggedCard.dragOffsetY;
                    draw();
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'grab';
                saveToLocalStorage(); // Save pan position
            } else if (draggedCard) {
                const clickDuration = Date.now() - clickStartTime;
                const rect = canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const canvasCoords = screenToCanvas(screenX, screenY);

                if (isDraggingForConnection) {
                    // Check if dropped on another card
                    for (let card of cards) {
                        if (card !== draggedCard && card.containsPoint(canvasCoords.x, canvasCoords.y)) {
                            // Check if connection already exists
                            const exists = connections.some(
                                conn => conn.from === draggedCard && conn.to === card
                            );
                            if (!exists) {
                                connections.push({ from: draggedCard, to: card });
                                saveToLocalStorage(); // Save new connection
                            }
                            break;
                        }
                    }
                    saveToLocalStorage(); // Save card position after drag
                } else if (clickDuration < 200) {
                    // Quick click - toggle expand/collapse
                    if (draggedCard.containsHeaderPoint(canvasCoords.x, canvasCoords.y)) {
                        draggedCard.toggleExpanded();
                        saveToLocalStorage(); // Save expanded state
                    }
                }

                draggedCard = null;
                isDraggingForConnection = false;
                draw();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            draggedCard = null;
            isDraggingForConnection = false;
            isPanning = false;
            canvas.style.cursor = 'grab';
            draw();
        });

        // Edit overlay functionality
        const editOverlay = document.getElementById('edit-overlay');
        const editTitle = document.getElementById('edit-title');
        const editContent = document.getElementById('edit-content');
        const editSave = document.getElementById('edit-save');
        const editCancel = document.getElementById('edit-cancel');
        let editingCard = null;

        function showEditOverlay(card, x, y) {
            editingCard = card;
            editTitle.value = card.title;
            editContent.value = card.content;
            
            // Position the overlay near the click but ensure it's visible
            const overlayX = Math.min(x, canvas.width - 350);
            const overlayY = Math.min(y, canvas.height - 250);
            
            editOverlay.style.left = overlayX + 'px';
            editOverlay.style.top = overlayY + 'px';
            editOverlay.classList.add('active');
            
            editTitle.focus();
            editTitle.select();
        }

        function hideEditOverlay() {
            editOverlay.classList.remove('active');
            editingCard = null;
        }

        editSave.addEventListener('click', () => {
            if (editingCard) {
                editingCard.title = editTitle.value || 'Untitled';
                editingCard.content = editContent.value;
                
                // Recalculate height if card is expanded
                if (editingCard.expanded) {
                    editingCard.height = editingCard.calculateExpandedHeight();
                }
                
                saveToLocalStorage(); // Save edited card
                draw();
            }
            hideEditOverlay();
        });

        editCancel.addEventListener('click', () => {
            hideEditOverlay();
        });

        // Keyboard shortcuts for editing
        editTitle.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                editSave.click();
            } else if (e.key === 'Escape') {
                editCancel.click();
            }
        });

        editContent.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                editCancel.click();
            }
            // Allow Enter for new lines in textarea
        });

        // Double-click to create new card or edit existing or delete connection
        let lastClickTime = 0;
        let lastClickX = 0;
        let lastClickY = 0;

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const canvasCoords = screenToCanvas(screenX, screenY);
            const now = Date.now();

            if (now - lastClickTime < 300 && 
                Math.abs(screenX - lastClickX) < 10 && 
                Math.abs(screenY - lastClickY) < 10) {
                
                // Check if clicking on a connection
                const connectionIndex = findConnectionAtPoint(canvasCoords.x, canvasCoords.y);
                if (connectionIndex !== -1) {
                    // Delete the connection
                    connections.splice(connectionIndex, 1);
                    saveToLocalStorage(); // Save after deletion
                    draw();
                    lastClickTime = 0; // Reset to prevent triple-click issues
                    return;
                }

                // Check if clicking on an existing card
                let clickedCard = null;
                for (let i = cards.length - 1; i >= 0; i--) {
                    if (cards[i].containsPoint(canvasCoords.x, canvasCoords.y)) {
                        clickedCard = cards[i];
                        break;
                    }
                }

                if (clickedCard) {
                    // Edit existing card
                    showEditOverlay(clickedCard, screenX, screenY);
                } else {
                    // Create new card at double-click position
                    const newCard = new Card(
                        canvasCoords.x - 140, // Center card on click
                        canvasCoords.y - 30,
                        { title: 'New Note', content: '' },
                        cards.length
                    );
                    cards.push(newCard);
                    saveToLocalStorage(); // Save new card
                    draw();
                    
                    // Show edit overlay for new card
                    showEditOverlay(newCard, screenX, screenY);
                }
            }

            lastClickTime = now;
            lastClickX = screenX;
            lastClickY = screenY;
        });

        // Close overlay when clicking outside
        document.addEventListener('click', (e) => {
            if (editOverlay.classList.contains('active') && 
                !editOverlay.contains(e.target) && 
                e.target !== canvas) {
                hideEditOverlay();
            }
        });

        // Reset button functionality
        const resetButton = document.getElementById('reset-button');
        resetButton.addEventListener('click', () => {
            if (confirm('Are you sure you want to reset the canvas? This will delete all your cards, connections, and loaded files.')) {
                localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem(STORAGE_KEY_FILES);
                location.reload();
            }
        });

        // Load files button functionality
        const loadButton = document.getElementById('load-button');
        const fileInput = document.getElementById('file-input');
        
        loadButton.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            
            if (files.length === 0) return;

            // Confirm if there's existing work
            if (cards.length > 0) {
                const confirmed = confirm(`Load ${files.length} new file(s)? Your current work will be replaced.`);
                if (!confirmed) {
                    fileInput.value = ''; // Reset file input
                    return;
                }
            }

            // Clear existing state
            cards.length = 0;
            connections.length = 0;
            loadedFiles = [];
            panOffsetX = 0;
            panOffsetY = 0;

            let cardIndex = 0;

            // Read all files
            for (let file of files) {
                try {
                    const text = await file.text();
                    
                    // Check if file contains card separators
                    if (text.includes('#-------')) {
                        // Parse as multiple cards
                        const cardData = parseMarkdown(text);
                        
                        for (let data of cardData) {
                            // Store file data
                            loadedFiles.push({ title: data.title, content: data.content });
                            
                            // Create card
                            const card = new Card(
                                stackX,
                                stackY + (cardIndex * stackOffset),
                                data,
                                cardIndex
                            );
                            cards.push(card);
                            cardIndex++;
                        }
                    } else {
                        // Parse as single card
                        const lines = text.trim().split('\n');
                        
                        let title = file.name.replace(/\.md$|\.markdown$/i, '');
                        let content = text;
                        
                        // If first line is a heading, use it as title
                        if (lines[0].startsWith('#')) {
                            title = lines[0].replace(/^#+\s*/, '').trim();
                            content = lines.slice(1).join('\n').trim();
                        }
                        
                        // Store file data
                        loadedFiles.push({ title, content });
                        
                        // Create card
                        const card = new Card(
                            stackX,
                            stackY + (cardIndex * stackOffset),
                            { title, content },
                            cardIndex
                        );
                        cards.push(card);
                        cardIndex++;
                    }
                } catch (error) {
                    console.error(`Failed to read file ${file.name}:`, error);
                    alert(`Could not read ${file.name}`);
                }
            }

                
// Save files and canvas state
            saveFilesToLocalStorage();
            saveToLocalStorage();
            draw();

            // Reset file input for next use
            fileInput.value = '';
        });


            // Export to markdown functionality
        const exportButton = document.getElementById('export-button');
        exportButton.addEventListener('click', () => {
            // 1. Build Adjacency List (Undirected: A-B is the same as B-A)
            // This allows us to find "groups" regardless of which way you drew the arrow
            const adjacency = new Map();
            cards.forEach(c => adjacency.set(c, []));
            connections.forEach(conn => {
                adjacency.get(conn.from).push(conn.to);
                adjacency.get(conn.to).push(conn.from);
            });

            // 2. Identify Connected Components (Clusters)
            const visited = new Set();
            const clusters = [];

            cards.forEach(card => {
                if (visited.has(card)) return;

                // Check if this card actually has any connections
                // (We want to ignore isolates)
                const hasConnections = (adjacency.get(card) || []).length > 0;
                if (!hasConnections) return;

                // Perform BFS to find all cards in this connected group
                const cluster = [];
                const queue = [card];
                visited.add(card);

                while (queue.length > 0) {
                    const current = queue.shift();
                    cluster.push(current);

                    const neighbors = adjacency.get(current) || [];
                    neighbors.forEach(neighbor => {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push(neighbor);
                        }
                    });
                }

                clusters.push(cluster);
            });

            if (clusters.length === 0) {
                alert('No connected cards to export! Connect cards by dragging one onto another.');
                return;
            }

            // 3. Process Clusters for Output
            // A. Sort cards INSIDE each cluster by Y-position (Visual Top-Down)
            clusters.forEach(cluster => {
                cluster.sort((a, b) => a.y - b.y);
            });

            // B. Sort the CLUSTERS themselves by the Y-position of their top-most card
            // This ensures "Chapter 1" (Top) comes before "Chapter 2" (Bottom)
            clusters.sort((a, b) => a[0].y - b[0].y);

            // C. Flatten into one list
            const orderedCards = clusters.flat();

            // 4. Generate Markdown
            let markdown = '';
            for (let i = 0; i < orderedCards.length; i++) {
                const card = orderedCards[i];
                
                // Using Markdown Heading for title
                markdown += `# ${card.title}\n`;
                
                // Add card content
                if (card.content) {
                    markdown += card.content + '\n';
                }
                
                // Add separator (unless it's the very last card)
                if (i < orderedCards.length - 1) {
                    markdown += '\n#-------\n';
                }
            }

            // Create and download the file
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'outline-export.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Initialize canvas size and start the app
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        initializeCards(); // Load and draw cards
    </script>
</body>
</html>
